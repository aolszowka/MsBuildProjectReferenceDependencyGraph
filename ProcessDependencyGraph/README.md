# ProcessDependencyGraph
Utility to perform further processing on a DOT Graph generated by `MsBuildProjectReferenceDependencyGraph`.

Several questions can be answered by a dependency graph; but the two most important questions usually are:

1. What Projects Does a Specific Project Depend On To Build?
2. What Projects Will I Affect if a Specific Project is Modified?
3. If I Removed a Single Project, How Many Projects Would Be Removed?

Question 1 is answered by the entire output of MsBuildProjectReferenceDependencyGraph for the "primary project"; however in general when you are viewing these trees you are attempting to remove some dependency therefore you want to ask:

For this context if I remove a dependency will I really change the dependency tree?

Consider the following dependency graph:

```
digraph {
A -> B
B -> C
A -> D
D -> B
A -> C
}
```

In this case you are investigating removing the A -> B reference (as it is no longer needed). While this will reduce the number of inter-dependencies it does not reduce the total number of projects required to build (Question 1 and Question 3).

It does however reduce the number of projects that are affected when modifications to B are made (Question 2).

Because of the limitations of the tooling this can only answer these questions with respect to the graph that was loaded (which is usually a solution file). However this is usually scope of the question being asked.

## Usage
`ProcessDependencyGraph in.g -TargetProject B.csproj [-IdentifyRequiredProjects/-irp|-IdentifyAffectedProjects/-iap|-IdentifyDirectDependencyCounts/-iddc] > out.g`

The usage of each flag is detailed below.

Because the output is simply piped to Standard Out we redirect it to an output file for further processing by other utilities.

For example you can use Webgraphviz (http://www.webgraphviz.com/) to produce a graph online or download and install GraphViz (https://graphviz.gitlab.io/)

## Flags
The first argument must __always__ be the DOT Graph file to operate on.

All switches are case insensitive and can use either `/` or `-` as their flag.

### -TargetProject (-tp)
This flag is __always__ required; although the order in which it is given (always after the DOT Graph argument) does not matter.

Indicates to the program from what perspective you would like the graph evaluated.

In general you will want to evaluate from the highest level project. This is generally the primary project that `MsBuildProjectReferenceDependencyGraph` was executed on. However when exploring the underlying dependency tree it is sometimes helpful to target other projects within the given tree for further evaluation.

__The remainder of the flags cannot be used at the same time; the behavior when multiple of these flags is given, is intentionally undefined.__

### -IdentifyRequiredProjects (-irp)
`ProcessDependencyGraph in.g -TargetProject B.csproj -IdentifyRequiredProjects > out.g`

Answers the question: "What Projects Do I Depend On?"

The `TargetProject` will be highlighted in `Yellow`, and all projects which are required in order to build the `TargetProject` will be highlighted in `Green`.


### -IdentifyAffectedProjects (-iap)
`ProcessDependencyGraph in.g -TargetProject B.csproj -IdentifyAffectedProjects > out.g`

Answers the question: "What Projects Do I Affect?"

The `TargetProject` will be highlighted in `Yellow`, and all projects which would be required to rebuild if the `TargetProject` changes will be highlighted in `Red`.

### -IdentifyDirectDependencyCounts (-iddc)
`ProcessDependencyGraph in.g -TargetProject B.csproj -IdentifyAffectedProjects > out.g`

Answers the question: "If I Removed a Single Project, How Many Projects Would Be Removed?"

To explain this using a simple example consider the following Dependency Graph:

```
digraph {
A -> B
A -> C
C -> D
B -> D
B -> E
}
```

Running this tooling yields this graph:

```
digraph {
"A" [style=filled, fillcolor=yellow, fontname="consolas", fontcolor=black]
"A" -> "B"
"A" -> "C"
"B" [style=filled, fillcolor="#336699", fontname="consolas", fontcolor=black, label="B (1)"]
"B" -> "D"
"B" -> "E"
"C" [style=filled, fillcolor="#99CCFF", fontname="consolas", fontcolor=black, label="C (0)"]
"C" -> "D"
"D" [fontname="consolas", fontcolor=black]
"E" [style=filled, fillcolor="#336699", fontname="consolas", fontcolor=black]
}
```

In this example We are trying to reduce the number of dependencies, therefore we should focus our efforts on `B`. This is because if we can remove `B` we can remove at least 2 projects. Whereas if we removed `C` we would only be able to remove a single project. This is because `B` and `C` both contain a reference to `D`.

As you can see in the Graph `B` has been annotated with a `(1)` to indicate that in addition to removing this project 1 additional N-Order Dependency will be removed as part of its removal. Whereas `C` has been annotated with a `(0)` to indicate that removal of `C` will result in no additional N-Order removals.

To assist in quickly visually identifying these situations the tooling will also highlight each of the _Direct_ Dependencies using a unique color, and then if an N-Order Dependency is required _only because of that direct dependency_ it will be highlighted in the same color. Due to this behavior there is a limit on the number of _Direct_ Dependencies that can be mapped with this switch.


This question becomes very complicated in a complex dependency tree (see /`ProcessDependencyGraph.Tests/IdentifyDirectDependencyCountsTests/TestCase2_Result.g` for a good example of the types of complexity this tool is designed to operate on).

Unfortunately there are limitations to what can be evaluated within a reasonable and understandable manner. It is very possible that removal of certain combinations of dependencies will result in more N-Order projects being removed. This tool only attempts a naive removal of a single project at a time, and should only be used as a gut check for those looking to simplify their dependency tree.

## License
This is licensed under the MIT License.

## Hacking
The most obvious limitation today is the fact that the color schemes for `-IdentifyDirectDependencyCounts` are hard coded. I would welcome any pull requests that came up with a programmatic solution to generate readable color schemes.

## Bugs/Feature Requests
I accept pull requests and am responsive on GitHub, Let me know!
